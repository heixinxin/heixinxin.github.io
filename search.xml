<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis设计与实现</title>
      <link href="/2020/03/24/redis-she-ji-yu-shi-xian/"/>
      <url>/2020/03/24/redis-she-ji-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>正直春招时期，看到一些大厂后端面经。心底拔凉拔凉的，啥玩意？平时都只是注重应用层（会用就行了），没有接触一些底层。但是……一些大厂的面试官就会问你一些关于底层的东西。:triumph:</p><p>吓得我赶紧读本<code>redis设计与实现</code>压压惊。全书有24章，坚持每天读一章，并记录。第一章是引言，所以过。</p><h3 id="第2章-简单动态字符串"><a href="#第2章-简单动态字符串" class="headerlink" title="第2章 简单动态字符串"></a>第2章 简单动态字符串</h3><p>redis没有使用c语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作redis的默认字符串表示。</p><h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><p>每个sds.h/sdshdr结构表示一个SDS值：</p><pre><code>struct sdshdr{    // 记录buf数组中已使用字节的数量    // 等于SDS所保存字符串的长度    int len;    // 记录buf数组中未使用字节的数量    int free;    // 字节数组，用于保存字符串    char buf[];};</code></pre><p><img src="/images/SDS.png" alt="SDS示例.png"></p><h4 id="SDS与c字符串的区别"><a href="#SDS与c字符串的区别" class="headerlink" title="SDS与c字符串的区别"></a>SDS与c字符串的区别</h4><ul><li>常数复杂度获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串时带来的内存重分配次数<ul><li>空间预分配</li><li>惰性空间释放</li></ul></li><li>二进制安全</li><li>兼容部分C字符串函数<br>总结：</li></ul><table><thead><tr><th>C字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O（N）</td><td>获取字符串长度的复杂度为O（1）</td></tr><tr><td>API是不安全的，可能会造成缓冲区溢出</td><td>API是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度N次必然需要执行N次内存重分配</td><td>修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本或者二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><p>Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS作为字符串表示。</p><h3 id="第3章-链表"><a href="#第3章-链表" class="headerlink" title="第3章 链表"></a>第3章 链表</h3><p>作为一种常用的数据结构，链表内置在很多高级的编程里面，因为Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现。</p><h4 id="Redis链表实现的特性"><a href="#Redis链表实现的特性" class="headerlink" title="Redis链表实现的特性"></a>Redis链表实现的特性</h4><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头结点和表尾节点的复杂度为O（1）。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h4 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ul><h3 id="第4章-字典"><a href="#第4章-字典" class="headerlink" title="第4章 字典"></a>第4章 字典</h3><h4 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</li><li>Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</li><li>当字典被用作数据库的底层实现，或者哈希键的底层是现实，Redis使用MurmurHash2算法来计算键的哈希值。</li><li>哈希表使用链地址法来解决冲突，被非配到同一个索引上的多个键值对会连接成一个单向链表。</li><li>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。</li></ul><h3 id="第5章-跳跃表"><a href="#第5章-跳跃表" class="headerlink" title="第5章 跳跃表"></a>第5章 跳跃表</h3><p>跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O（log^N）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><h4 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>跳跃表是有序集合的底层实现之一。</li><li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是1~32之间的随机数。</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是惟一的。</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li></ul><h3 id="第6章-整数集合"><a href="#第6章-整数集合" class="headerlink" title="第6章 整数集合"></a>第6章 整数集合</h3><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br>每个intset.h/intset结构表示一个整数集合：</p><pre><code>typedef struct intset{    // 编码方式    uint32_t encoding;    // 集合包含的元素数量    uint32_t length;    // 保存元素的数组    int8_t contents[];}</code></pre><p>contents数组是整数集合的底层实现：数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p><h4 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>整数集合是集合键的底层实现之一。</li><li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。</li><li>升级操作为整个集合带来了操作上的灵活性，并且尽可能地节约了内存。</li><li>整数集合只支持升级操作，不支持降级操作。</li></ul><h3 id="第7章-压缩列表"><a href="#第7章-压缩列表" class="headerlink" title="第7章 压缩列表"></a>第7章 压缩列表</h3><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。</p><h4 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>压缩列表是一种为节约内存而开发的顺序型数据结构</li><li>压缩列表被用作列表键和哈希键的底层实现之一。</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</li></ul><h3 id="第8章-对象"><a href="#第8章-对象" class="headerlink" title="第8章 对象"></a>第8章 对象</h3><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr。<br>| 值 | 编码 |<br>| —- | —- |<br>| 可以用long类型保存的整数 | int |<br>| 可以用long double类型保存的浮点数 | embstr或者raw |<br>| 字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没办法用long double类型表示的浮点数 | embstr或者raw |</p><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。</p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的编码可以是ziplist或者linkedlist。<br>当列表对象可以同时满足一下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节</li><li>列表对象保存的元素数量小于512个，不能满足这两个条件的列表对象需要使用linkedlist编码。<br><code>以上两个条件的上限值是可以修改的</code><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4>哈希对象的编码可以是ziplist或者hashtable。<br>编码转换条件上限值如上列表对象的上限值。<h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4>集合对象的编码可以是intset或者hashtable。<br>当集合对象可以同时满足一下两个条件时，对象使用intset编码：</li><li>集合对象保存的所有元素都是整数值。</li><li>集合对象保存的元素数量不超过512个。<br>不能满足这两个条件的集合对象需要使用hashtable编码。<h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4>有序集合的对象编码可以是ziplist或者skiplist。<br>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。<br><img src="/images/zset.png" alt="跳跃表和字典的同时使用"><br>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</li><li>有序集合保存的元素数量小于128个；</li><li>有序集合保存的所有元素成员的长度都小于64字节。<br>不能满足以上两个条件的有序集合对象将使用skiplist编码。<h4 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h4>redis中用于操作键的命令基本上可以分为两种类型。<br>其中一种命令可以对任何类型的键执行，比如说del、expire、rename、type、object命令等。<br>还有一种命令只能对特定类型的键执行，比如说：</li><li>set、get、append、strlen等命令只能对字符串键执行。</li><li>hdel、hset、hget、hlen等只能对哈希键执行。</li><li>rpush、lpop、linsert、llen等只能对列表键执行。</li><li>sadd、spop、sinter、scard等只能对集合键执行。</li><li>zadd、zcard、zrank、zscore等只能对有序集合键执行。</li></ul><p>del、expire等命令和llen等命令的区别在于，前者是基于类型的多态–一个命令可以同时用于处理多种不同类型的键。而后者是基于编码的多态–一个命令可以同时用于处理多种不同的编码。</p><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>因为C语言并不具备自动内存回收功能，所以redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制。</p><ul><li>创建一个新对象时，计数初始化1</li><li>对象被新程序使用时，计数值+1</li><li>对象不再被一个程序使用时，计数值-1</li><li>对象计数值为0时，对象所占用的内存会被释放。</li></ul><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>目前来说，redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。<br><img src="/images/str.png" alt="为什么不共享字符串"></p><h4 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h4><p>object idletime命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru（该属性记录了对象最后一次被访问的时间）时间计算得出的。</p><h4 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>redis数据库中的每个键值对的键和值都是一个对象</li><li>redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li><li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</li><li>redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</li><li>redis会共享值为0到9999的字符串对象。</li><li>对象会记录自己的最后一次被访问的时间。这个时间可以用于计算对象的空转时间。</li></ul><h3 id="第9章-数据库"><a href="#第9章-数据库" class="headerlink" title="第9章 数据库"></a>第9章 数据库</h3><h4 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h4><p>dbnum（服务器的数据库数量）属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16，所以redis服务器默认会创建16个数据库。</p><h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><p>通过expire命令或者pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL）。<br>设置过期时间命令：expire（秒）、pexpire（毫秒）、expireat（秒时间戳）、pexpireat（毫秒时间戳），<br>虽然有多种不同单位和不同形式的设置命令，但实际上expire、pexpire、expireat三个命令都是使用pexpireat命令来实现的：无论客户端执行的是以上四个命令的哪一个，经过转换之后，最终都会转换为pexpireat命令执行。<br>ttl（返回：秒）、pttl（返回：毫秒）命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间。也就是距离这个键被删除还有多长时间。<br>移除过期时间命令：persist，它会解除键和值（过期时间）在过期字典中的关联。</p><h4 id="redis的过期键删除策略"><a href="#redis的过期键删除策略" class="headerlink" title="redis的过期键删除策略"></a>redis的过期键删除策略</h4><p>redis服务器实际使用的是惰性删除和定期删除两种策略，通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h4 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h4><p>AOF、RDB都是redis数据持久化的方式。</p><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上。<br>在执行save命令或者bgsave命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中</p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写执行记录下来，在下次redis重新启动时，只要把这些写指令从前到后在重复执行一遍，就可以实现数据恢复了。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><h4 id="重点回顾-7"><a href="#重点回顾-7" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则是由redisServer.dbnum属性保存。</li><li>客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</li><li>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</li><li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li><li>数据库的键总是一个字符串对象，而值则可以是任意一种redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。</li><li>expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的unix时间戳。</li><li>redis使用惰性删除和定时删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li><li>执行save命令或者bgsave命令所产生的新RDB文件不会包含已经过期的键。</li><li>执行bgrewriteaof命令所产生的重写AOF文件不会包含已经过期的键。</li><li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li><li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</li><li>从服务器即使发现过期键也不会自作主张的删除它，而是等待主节点发来DEL命令。这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li><li>当redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li></ul><h3 id="第10章-RDB持久化"><a href="#第10章-RDB持久化" class="headerlink" title="第10章 RDB持久化"></a>第10章 RDB持久化</h3><h4 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h4><p>有两个redis命令可以用于生成RDB文件，一个<code>save</code>，另一个<code>bgsave</code>。<br>save命令会阻塞redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。<br>bgsave命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。<br>RDB文件的载入是在服务器启动时自动执行的，只要redis检测到RDB文件存在就会自动载入RDB文件。</p><h4 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h4><p>用户可以通过save选项设置多个保存条件，但只要其中人一个条件被满足，服务器就会自动执行bgsave命令保存。如：<br>save 900 1     （900秒内，至少1次修改）<br>save 300 10    （300秒内，至少10次修改）<br>save 60  10000 （60秒内，至少10000次修改）<br>redis是通过dirty计数器（修改次数）和lastsave（上次保存的时间）属性来检查保存条件是否被满足。</p><h4 id="重点回顾-8"><a href="#重点回顾-8" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>RDB文件用于保存和还原redis服务器所有数据库中的所有键值对数据。</li><li>save命令有服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li><li>bgsave命令由子进程执行保存操作，所以该命令不会阻塞服务器。</li><li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行bgsave命令。</li><li>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</li><li>对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。</li></ul><h3 id="第11章-AOF持久化"><a href="#第11章-AOF持久化" class="headerlink" title="第11章 AOF持久化"></a>第11章 AOF持久化</h3><p> AOF持久化是通过保存redis服务器所执行的写命令来记录数据库状态的。</p><h4 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h4><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大。<br>如果不加以控制很可能对redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。<br>AOF重写是通过读取数据库内容，生成对应的存命令写入AOF文件中。最后替换掉原有的AOF文件实现AOF重写。</p><h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>redis把AOF重写程序放到子进程里执行。可以达到服务器进程（父进程）可以继续处理命令请求。<br>但是还有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新命令可能对现有的数据库状态进行修改，从而使得当前数据库与重写的AOF文件所保存的数据库不一致。<br>为了解决这个问题，redis服务器设置了一个AOF重写缓冲区，当redis服务器执行完一个写命令之后，他会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。<br>这样当子进程完成AOF重写后，它会向父进程发送一个信号，父进程在接收到这个信号后，将AOF重写缓冲区中的所有内容写入到新AOF文件中，实现了数据库状态一致。在对新AOF文件进行改名，覆盖现有的AOF文件，实现替换。</p><h4 id="重点回顾-9"><a href="#重点回顾-9" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>AOF文件通过保存所有修改数据库写命令请求来记录服务器的数据库状态。</li><li>AOF文件中的所有命令都以redis命令请求协议的格式保存。</li><li>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</li><li><code>appendfsync</code>选项的不同值对AOF持久化功能的安全性以及redis服务器的性能有很大的影响。</li><li>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。</li><li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</li><li>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入，分析或者写入操作。</li><li>在执行<code>bgrewriteaof</code>命令时，redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。</li></ul><p>当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，是的新旧两个AOF文件所保存的数据库状态一致。<br>最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p><h3 id="第12章-事件"><a href="#第12章-事件" class="headerlink" title="第12章 事件"></a>第12章 事件</h3><p>redis服务器是一个事件驱动程序，服务器需要处理两类事件：文件事件、时间事件。<br>文件事件：redis服务器通过套接字与客户端（或者其他redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。<br>时间事件：redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</p><h4 id="重点回顾-10"><a href="#重点回顾-10" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>redis服务器是一个时间驱动程序，服务器处理的事件分为时间事件和文件事件两类。</li><li>文件事件处理器是基础Reactor模式实现的网络通信程序。</li><li>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</li><li>文件事件分为AE_READABLE事件（读事件）和AE_WRITABLE事件（写事件）两类。</li><li>时间事件分为定时事件和周期事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li><li>服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。</li><li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li><li>时间事件的实际处理时间通常会比设定的到达时间晚一些。</li></ul><h3 id="第13章-客户端"><a href="#第13章-客户端" class="headerlink" title="第13章 客户端"></a>第13章 客户端</h3><p>执行client list命令可以列出目前所有连接到服务器的不同客户端，命令输出中的fd域显示了服务器连接客户端所使用的套接字描述符。</p><h4 id="重点回顾-11"><a href="#重点回顾-11" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li><li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li><li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li><li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li><li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li><li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li><li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求，成为client kill命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li><li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li><li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li></ul><h3 id="第14章-服务器"><a href="#第14章-服务器" class="headerlink" title="第14章 服务器"></a>第14章 服务器</h3><h4 id="命名请求的执行过程"><a href="#命名请求的执行过程" class="headerlink" title="命名请求的执行过程"></a>命名请求的执行过程</h4><ul><li>发送命令请求</li><li>读取命令请求<br>读取命令请求调用命令执行器执行如下步骤：<br>1）查找命令实现<br>2）执行预备操作<br>3）调用命令的实现函数<br>4）执行后续工作</li></ul><h4 id="重点回顾-12"><a href="#重点回顾-12" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>一个命令请求从发送到完成主要包括以下步骤：<br>1）客户端命令请求发送给服务器；<br>2）服务器读取命令请求，并分析出命令参数；<br>3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；<br>4）服务器将命令回复返回给客户端；</li><li>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的sigterm信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。</li><li>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：<br>1）初始化服务器状态；<br>2）载入服务器配置；<br>3）初始化服务器数据结构；<br>4）还原数据库状态；<br>5）执行时间循环；</li></ul><h3 id="第15-17章"><a href="#第15-17章" class="headerlink" title="第15~17章"></a>第15~17章</h3><p>由于这3章讲的是多机数据库的实现，我还暂时没使用到过，所以先放一放。之后再来研究研究。</p><h3 id="第18章-发布与订阅"><a href="#第18章-发布与订阅" class="headerlink" title="第18章 发布与订阅"></a>第18章 发布与订阅</h3><h4 id="重点回顾-13"><a href="#重点回顾-13" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>服务器状态在pubsub_channels字典保存了所有频道的订阅关系：</li></ul><ol><li>subscribe命令负责将客户端和被订阅的频道关联到这个字典里面，</li><li>unsubscribe命令则负责解除客户端和被退订频道之间的关联。</li></ol><ul><li>服务器状态在pubsub_patterns链表保存了所有模式的订阅关系：</li></ul><ol><li>psubscribe命令负责将客户端和被订阅的模式记录到这个链表中。</li><li>punsubscribe命令则负责移除客户端和被退订模式在链表中的记录。</li></ol><ul><li>publish命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息，通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息。</li><li>pubsub命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的。</li></ul><ol><li>pubsub channels <code>pattern</code> pattern参数是可选的，来返回服务器目前被订阅的频道</li><li>pubsub numsub子命令可以接受任意多个频道作为输入参数，并返回这些频道的订阅数量</li><li>pubsub numpat子命令用于返回服务器当前被订阅模式的数量。 </li></ol><h3 id="第19章-事务"><a href="#第19章-事务" class="headerlink" title="第19章 事务"></a>第19章 事务</h3><h4 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h4><p>一个事务从开始到结束通常会经历以下三个阶段：<br>1）事务开始。<br>2）命令入队。<br>3）事务执行。</p><h4 id="WATCH命令"><a href="#WATCH命令" class="headerlink" title="WATCH命令"></a>WATCH命令</h4><p>watch命令是一个乐观锁，他可以在exec命令执行之前，监视任意数量的数据库键，并在exec命令执行时，检查被监视的键是否至少有一个已经被修改过了，<br>如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。<br>当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了redis_dirty_cas标识来决定是否执行事务。</p><h4 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h4><p>在传统的关系式数据库中，常常用ACID性质来检验事务功能的可靠性和安全性。<br>在redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），<br>并且当redis运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。</p><h4 id="重点回顾-14"><a href="#重点回顾-14" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li><li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li><li>事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。</li><li>带有watch命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的redis_dirty_cas标志打开。</li><li>只有在客户端的redis_dirty_cas标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。</li><li>redis的事务总是具有ACID中的原子性、一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</li></ul><h3 id="第20章-Lua脚本"><a href="#第20章-Lua脚本" class="headerlink" title="第20章 Lua脚本"></a>第20章 Lua脚本</h3><ul><li>redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足redis在功能性、安全性等方面的需要。</li><li>redis服务器专门使用一个伪客户端来执行Lua脚本中包含的redis命令。</li><li>redis使用脚本字典来保存所有被eval命令执行过，或者被script load命令载入过的Lua脚本，这些脚本可以用于实现script exists命令，以及实现脚本复制功能。</li><li>eval命令为客户端输入的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。</li><li>evalsha命令通过直接调用Lua环境中已定义的函数来执行脚本。</li><li>script flush命令会清空服务器lua_scripts字典中保存的脚本，并重置Lua环境。</li><li>script exists命令接受一个或多个sha1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。</li><li>script load命令接受一个Lua脚本为参数，为该脚本在Lua环境中创建函数，并将脚本保存到lua_scripts字典中。</li><li>服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行情况时，客户端可以通过向服务器发送script kill命令来让钩子停止正在执行的脚本，或者发送shutdown nosave命令来让钩子关闭整个服务器。</li><li>主服务器复制eval、script flush、script load三个命令的方法和复制普通redis命令一样，只要将相同的命令传播给从服务器就可以了。</li><li>主服务器在复制evalsha命令时，必须确保所有从服务器都已经载入了evalsha命令指定的sha1校验和所对应的Lua脚本，如果不能确保这一点的话，主服务器会将evalsha命令转换成等效的eval命令，并通过传播eval命令来获得相同的脚本执行效果。</li></ul><h3 id="第21章-排序"><a href="#第21章-排序" class="headerlink" title="第21章 排序"></a>第21章 排序</h3><ul><li>sort命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作。</li><li>在默认情况下，sort命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序。</li><li>如果sort命令使用了alpha选项，那么sort命令假设被排序键包含的都是字符串值，并且以字符串的方式来进行排序。</li><li>sort命令的排序操作由快速排序算法实现。</li><li>sort命令会根据用户是否使用了desc选项来决定是使用升序对比还是降序对比来比较被排序的元素，升序对比会按值的大小从小到大排列，降序对比会按值的大小从大到小排列。</li><li>当sort命令使用了by选项时，命令使用其他键的值作为权重来进行排序操作的。</li><li>当sort命令使用了limit选项时，命令只保留排序结果集中limit选项指定的元素。</li><li>当sort命令使用get选项时，命令会根据排序结构集中的元素，以及get选项给定的模式，查找并返回其他键的值，而不是返回被排序的元素。</li><li>当sort命令使用了store选项时，命令会将排序结果集保存在指定的键里面。</li><li>当sort命令同时使用多个选项时，命令先执行排序操作（可用的选项为alpha、asc或desc、by），然后执行limit选项，之后执行get选项，再之后执行store选项，最后才将排序结果集返回给客户端。</li><li>除了get选项之外，调整选项的摆放位置不会影响sort命令的排序结果。</li></ul><h3 id="第22章-二进制位数组"><a href="#第22章-二进制位数组" class="headerlink" title="第22章 二进制位数组"></a>第22章 二进制位数组</h3><p>redis提供了setbit、getbit、bitcount、bitop四个命令用于处理二进制位数组（bit array，又称“位数组”）。<br>setbit命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制位的值则可以是0或者1.<br>getbit命令则用于获取位数组指定偏移量上的二进制位的值<br>bitcount命令用于统计位数组里面，值为1的二进制位的数量<br>bitop命令既可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）运算</p><h4 id="重点回顾-15"><a href="#重点回顾-15" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>redis使用SDS来保存位数组。</li><li>SDS使用逆序来保存位数组，这种保存顺序简化了setbit命令的实现，使得setbit命令可以在不移动现有二进制位的情况下，对位数组进行空间扩展。</li><li>bitcount命令使用了查表算法和variable-precision SWAR算法来优化命令的执行效率。</li><li>bitop命令的所有操作都使用C语言内置的位操作来实现。</li></ul><h3 id="第23章-慢查询日志"><a href="#第23章-慢查询日志" class="headerlink" title="第23章 慢查询日志"></a>第23章 慢查询日志</h3><p>redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p><h4 id="重点回顾-16"><a href="#重点回顾-16" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>redis的慢查询日志功能用于记录执行时间超过指定时长的命令。</li><li>redis服务器将所有的慢查询日志保存在服务器状态的slowlog链表中，每个链表节点都包含一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志。</li><li>打印和删除慢查询日志可以通过遍历slowlog链表来完成。</li><li>slowlog链表的长度就是服务器所保存慢查询日志的数量。</li><li>新的慢查询日志会被添加到slowlog链表的表头，如果日志的数量超过slowlog-max-len选项的值，那么多出来的日志会被删除。</li></ul><h3 id="第24章-监视器"><a href="#第24章-监视器" class="headerlink" title="第24章 监视器"></a>第24章 监视器</h3><p>通过执行monitor命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息。</p><h4 id="重点回顾-17"><a href="#重点回顾-17" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul><li>客户端可以通过执行monitor命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息。</li><li>当一个客户端从普通客户端变为监视器时，该客户端的redis_monitor标识会被打开。</li><li>服务器将所有监视器都记录在monitors链表中。</li><li>每次处理命令请求时，服务器都会遍历monitors链表，将相关信息发送给监视器。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> redis设计与实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颓废的我拯救颓废的你</title>
      <link href="/2020/03/20/yue-du-xin-de/"/>
      <url>/2020/03/20/yue-du-xin-de/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近各大互联网企业启动网申，作为一名大三学计算机的我肯定也蠢蠢欲动，第一次写简历，第一次投简历。感受到了简历石沉大海的感觉，也感受到自己离企业的标准很远很远，远到我无法企及……，就是那种感觉大学中学的知识全白学了，自己啥都不会。</p><h3 id="迷茫期"><a href="#迷茫期" class="headerlink" title="迷茫期"></a>迷茫期</h3><p>这段时间让我开始怀疑自己是否真的适合编程这个行业，整天靠着追剧、打游戏来麻痹自己。时间一天一天过，自己的内心反而越来越空虚，没有之前学习带来的那种满足感。导致不管干什么都填满不了自己内心的那种空洞。</p><p>直到今天思想决定着我不能再这样堕落下去了，中午在逛微信公众号时有幸看到一篇文章，讲述的也是大学生迷茫的一篇文章，写的很好，让我找到了前进的方向。迷茫不可怕，谁都会迷茫，不清楚自己想要的迷茫才可拍。思想很重要，有幸我的思想今天想让我读一本书，思量许久准备从理财方向下手，入门：<code>小狗钱钱</code>。<br>##《小狗钱钱的人生整理术》<br>这本书里面有三十个法则。每个法则对应8个字，后面都有实践练习，我会记录这些实践，从中摘选出了几个步骤练习：</p><h3 id="一、二、三法则"><a href="#一、二、三法则" class="headerlink" title="一、二、三法则"></a>一、二、三法则</h3><p><code>一：勇于抉择，勇于改变</code><br><code>二：终生学习，不断成长</code><br><code>三：珍惜今天，珍惜眼前</code></p><ol><li><p>每个月读两本有益于启迪心智的书籍，长此以往，循序渐进，最终达到每周读两本好书的频率。</p></li><li><p>在养成记录成功笔记习惯的同时在增加两份笔记：一份是日常笔记，记录我们的错误和从中能够吸取的教训；另一份是创意笔记，随时随地记录我们想到的好点子。</p></li><li><p>拿出纸笔，回答下列问题：五年之后，你希望自己变成什么样子？五年之后，你希望自己在做什么工作？五年之后，你希望自己拥有什么？在进行选择时，把这些答案作为自己的目标。我们要做好准备，学会对自己内心厌倦的东西说不，这样才能够自由地去追逐梦想。</p><p> 我：五年之后，希望那时候自己能快乐，有一个健康的身体，希望自己还在做程序猿吧……，希望拥有一个属于自己的小窝</p></li></ol><h3 id="四、五、六法则"><a href="#四、五、六法则" class="headerlink" title="四、五、六法则"></a>四、五、六法则</h3><p><code>四：高效工作，提高收入</code><br><code>五：陶冶心智，完善自我</code><br><code>六：说做就做，放手一搏</code></p><ol><li><p>考虑一下自己昨天是怎样分配时间的。提醒自己，如果不能更好地安排时间，不能专注于<code>创收工作</code>，我们的生活就不会发生质的飞跃。仔细反思，我们能够采取哪些具体的措施来加强那些决定收入的领域。</p></li><li><p>从今天开始，把自己的工作和公司视作可以帮助我们塑造成功人格和创造更好机遇的途径。在工作中投入更多的精力与热情，全力以赴创造成果，因为成果才是成功的标志。</p></li><li><p>从错误中吸取教训，不要再犯同样的错误，学习记录<code>日常笔记</code>，把所有从自己或别人的错误中得到的经验和教训都详细的记录下来。</p></li><li><p>阅读能够帮助我们提升心智、塑造性的书籍。少玩游戏，多读书，每天至少抽出一个小时阅读专业书籍</p></li><li><p>仔细看一看，自己是否在生活的五个主要领域（健康、社交、财务、情商和事业）全都树立了目标？</p></li><li><p>仔细想一想，自己有没有因为时机不好而把一些事情一拖在拖？这会不会只是一个借口？</p></li></ol><p>我觉得<code>说做就做，放手一搏</code>这法则说道我心坎上去了，你是否平常都会以一种借口而逃避某一件事呢？<br>我们应该常常对下列问题进行反思。</p><ol><li>你会不会因为害怕错误或丢脸而一再拖延，迟迟不敢放手去做呢？</li><li>有没有什么事情没有去做是因为你觉得<code>时机不对</code>？</li><li>你是不是总觉得对某件事情的准备还不够充分，还需要更多知识、更多经验、更好的基础？</li><li>你是否觉得好机会只有一次，因此不能过早地用掉，因为现在自己还“不够好”？</li></ol><p>看了这篇文章的人，对此我想说人生苦短，让我们扪心自问，这些问题其实是否只是我们为自己的不作为而寻找的接口呢？我们总能找出种种借口。但记住：<code>行动的最佳机会就是现在</code><br>其实爱情也是这样，喜欢就去表白，不要去想什么其他东西，你不去可能她就是别人的了。扯远了扯远了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8">😜</span></p><p><code>千里之行，始于足下</code>。任何事情在开始的时候都是一个试错的过程。摸索着开始胜于完美地等待。最好的“准备”方法就是说做就做</p><h3 id="七、八、九法则"><a href="#七、八、九法则" class="headerlink" title="七、八、九法则"></a>七、八、九法则</h3><p><code>七：笑对压力，泰然处之</code><br><code>八：克服困难，永攀高峰</code><br><code>九：虚心学习，诚心借鉴</code></p><ol><li>抓住生活的重点，为其留出足够的时间。我们应该按照这个准则来规划每周及每天的日程</li><li>不要将日程安排的过满。过分忙碌的人会渐渐失去理性思考的能力，最终只能被迫作出本能的反应</li><li>不要奢望能够永远成功。我们要学会接受生活中有冬有夏，有起有伏。</li></ol><p>笑对压力、克服困难、虚心学习。有压力是好的，但不要让压力冲昏了头脑。而困难成为拦路虎还是脚下石，选择权只在自己手中。</p><h3 id="十、十一、十二法则"><a href="#十、十一、十二法则" class="headerlink" title="十、十一、十二法则"></a>十、十一、十二法则</h3><p><code>十：全力以赴，勇往直前</code><br><code>十一：坚持梦想，追寻未来</code><br><code>十二：珍爱身体，勇往直前</code></p><ol><li>下定决心，全力以赴的工作，为自己积累足够的动量，让自己养成良好的习惯。因为我们已经知道，这样做不仅明智，而且更加经济。请记住，车轮一旦开始转动，我们就不用再像开始时耗费那么多的力气了。</li><li>从今天开始，认真就餐。减少食量，放慢进食速度，真正做到细嚼慢咽。多吃水果和蔬菜。想吃零食的时候，就为自己买一些坚果和水果。</li><li>保证每天的饮水量。饭前喝些水，这样能够避免不必要的大量饮食。</li><li>每天至少运动35分钟，每工作90分钟，就站起来活动一下身体。抽出5分钟，呼吸一下新鲜空气。<br>生活中不存在<code>试试</code>，<code>试着做</code>是一种不存在的状态。我们或者在做，或者没做，做事情全力投入的人期待的是成功，而<code>先试试看</code>的人期待的却是借口。</li></ol><h3 id="十三、十四、十五法则"><a href="#十三、十四、十五法则" class="headerlink" title="十三、十四、十五法则"></a>十三、十四、十五法则</h3><p><code>十三：鼓起勇气，面对非议</code><br><code>十四：十分努力，再加一分</code><br><code>十五：解决问题，学习成长</code></p><ol><li>从今天开始，将遭到的拒绝视为任我们随手拂去的尘土。我们已经知道，无论我们做什么，总会有人站出来拒绝。学会接受这一事实，不要将别人的批评全部归咎于自己。</li><li>与其妄想改变人性，不如将有限的精力投入到我们可以掌握的事情中去。例如：提高自身素质，或在工作中坚持自己的观点。</li><li>从今天开始，不要再给自己的能力设定界限。100%实际上是对自我能力的错误印象，我们要充分发挥自身潜力，成就最好的自我。没有“行不行”，只有“必须行”。</li></ol><h3 id="十六、十七、十八法则"><a href="#十六、十七、十八法则" class="headerlink" title="十六、十七、十八法则"></a>十六、十七、十八法则</h3><p><code>十六：雇主雇员，集于一身</code><br><code>十七：提高目标，胸怀大志</code><br><code>十八：予人所需，重人所想</code></p><ol><li>从今天起牢牢记住，创业者的成功与自律密不可分。逐渐培养自己的自律能力，不要忽略任何细节。今天要分秒不差地严格遵守自己制定的计划。</li><li>努力在自己心中将雇主与雇员合二为一。严格要求自己，像雇主监督雇员那样自我监督。为别人工作时比为自己工作时更卖力，这种行为实在让人难以接受。如果我们不能自律，就只能遵守别人的纪律；如果不能听命与自己的内心，就只有听命与他人。</li><li>回顾一下自己的长期目标，考虑一下自己是否应该制定一个更高的目标。长期目标会对我们的生活起到无可替代的影响，这个目标越宏大，我们的生活就会越紧张而充实。</li><li>不要和燕雀讨论鸿鹄之志，否则除了白费口舌和精力以外，我们还可能对自己产生疑惑。我们应该关心的是，能够帮助我们实现目标的人在哪里<br>有句话说的好，唯有心存鸿鹄之志，我们才能翱翔蓝天。</li><li>坚持使用“黄金法则”来生活（黄金法则24条我就不列举了）</li></ol><h3 id="十九、二十、二十一法则"><a href="#十九、二十、二十一法则" class="headerlink" title="十九、二十、二十一法则"></a>十九、二十、二十一法则</h3><p><code>十九：专注目标，拒绝干扰</code><br><code>二十：亲身尝试，以身作则</code><br><code>二十一：事有主次，择要先行</code></p><ol><li>从今天开始。不要给自己找任何借口。借口只能为我们带来干扰。时刻提醒自己，人生的掌握权在自己手中，我们不应该受制于所谓的形势。寻找借口无异于将人生的主动权拱手让与他人。我们应该将精力集中在实现目标而非寻找借口上。</li><li>不要因为干扰而放弃目标。完成今天计划的工作，做到今日事今日毕。</li><li>不可预见的干扰很难避免，所以在制订每日计划的时候要留出一定的时间。这样，我们就可以主动控制干扰而非被干扰控制。</li><li>马上审视一下自己的工作：我们是在过去的成功上坐吃上空，还是正在憧憬美好的未来？憧憬未来是正确的，但我们一定不能忘记，未来需要脚踏实地的行动作为见识的基础。</li><li>扪心自问，我们应该怎样改变自己的生活，才能让自己拥有更多的时间去解决最重要的事情，而不是每天在一堆所谓的“急事”间疲于奔命。</li><li>计划好的事情要在72小时内着手行动。至少要迈出行动的第一步。从今天起，要让大家为我们迅速的行动感到吃惊。从现在起，在行动时要牢记“今日之事，勿待明日”。</li></ol><h3 id="二十二、二十三、二十四法则"><a href="#二十二、二十三、二十四法则" class="headerlink" title="二十二、二十三、二十四法则"></a>二十二、二十三、二十四法则</h3><p><code>二十二：勇于担当，解放自身</code><br><code>二十三：克服恐惧，轻松生活</code><br><code>二十四：尺有所短，寸有所长</code></p><ol><li>从今天起，不再将责任推卸给他人或环境。归咎于人，就等于将决定权拱手让人。我们要做自己生活的主人。</li><li>如果有人恶语相加，我们不妨首先自我反省，看看是不是自己的行为令对方收到伤害或感到恐惧。同样，我们也要考虑是否自己的期望过高。</li></ol><h3 id="二十五、二十六、二十七法则"><a href="#二十五、二十六、二十七法则" class="headerlink" title="二十五、二十六、二十七法则"></a>二十五、二十六、二十七法则</h3><p><code>二十五：慷慨给予，宽宏大量</code><br><code>二十六：勤俭节约，善于理财</code><br><code>二十七：构建基础，持之以恒</code></p><ol><li>提醒自己，成功并非源于天赋，而是来自充分利用自身条件。所以，不要再抱怨命运不公。</li><li>对于自己无力左右的事情不要无谓纠缠。即使遭遇雷雨，我们也要保持愉快的心态，因为就算我们气恼，天依然会下雨。</li><li>认真反省自己是否存在羡慕或嫉妒的心态。这种心态不会自然消失，但只要我们发现了自身的潜力和独特之处，就不会再被其困扰。扪心自问：“我自己的独特之处在哪里？”将答案白纸黑字地记录下来。</li><li>从今天起，宽以待人。要做到这一点，我们首先要包容自己。想一想自己对谁心存怨恨，然后在心中原谅他们，最好立即着手给他们打电话或者写信。从今天开始，不要将对他人的负面感受记在心间，这样才能解放自己的心灵。</li><li>深刻体会“九重之台，起于累土”的道理，从今天起，积极完成目前的工作，逐步完善每日的工作方法。不要急于求成。因为我们知道，万丈高楼也是由一砖一瓦垒成的。</li><li>无论发生什么事，今天做任何工作都不要半途而废。过去，当计划无法实现时我们就会放弃，但从今天开始，我们要竭尽全力完成自己的既定计划。持之以恒从今天开始。<h3 id="二十八、二十九、三十法则"><a href="#二十八、二十九、三十法则" class="headerlink" title="二十八、二十九、三十法则"></a>二十八、二十九、三十法则</h3><code>二十八：创造环境，耳濡目染</code><br><code>二十九：永不知足，才有自由</code><br><code>三十：志为雄鹰，不为家鸭</code></li><li>让自己受到积极事物的熏陶。从今天开始，不在追看毫无价值的肥皂剧，也不要整日沉浸在各种电台的音乐之中。我们要有意识地选择自己要“记录”的信息。</li><li>接受自己的不满心理，因为它是一种重要的动力。满足现状会令我们止步不前，最终导致死亡。不满会推动我们积极进取，体验真正的生活。写下三个我们无论如何都要实现的目标。</li><li>认识到生活中其实并没有什么绝对的“赢家法则”，我们必须寻找自己的价值，才能确立适合自己的法则，引领我们踏上成功之路。</li></ol><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这本书打造的是一个完美地成功形象，可以让自己的人生活出精彩取得成功。但没有人能完全做到，你可以从中挑选出适合自己的法则并认真执行他，想法则靠拢，让自己每天都比昨天更优秀。</p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>好的书可以启迪你的心智，让你清楚自己真正想要什么。我从书中找到了那份满足感。以后我也会努力的坚持着看书，让看书成为一种习惯。<br>不断学习，努力成长。让自己变得更加的优秀。</p><p>看些观看，让我们一起加油！加油！加油！<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8">😘</span>    <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8">😘</span>    <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8">😘</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 阅读心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 小狗钱钱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍</title>
      <link href="/2020/02/19/bo-ke-jie-shao/"/>
      <url>/2020/02/19/bo-ke-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>搭建此博客主要是为了培养本人写文档的能力，说来惭愧，以前写博客总是断断续续、坚持不下来。每次写都是一时兴起之后就不管了。从今天开始争取每周写一篇，记录平时的点点滴滴。以后回来看自己写的这些该是多么的幸福的事情。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
